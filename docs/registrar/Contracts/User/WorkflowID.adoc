// TODO: I am still mixing requirements with explanations... should really split that up better... somehow

== Overview

A workflow ID is used for differentiating between different workflows.
The workflow ID consists of functions being concatenated together and a salt appended
to the end in order to handle collisions in the hashtable.

== Context

Each function will be validated by removing any spaces and ensuring that the arguments
that are provided into the function are valid for example the type `string` is valid
however `strings` does not exist and is thus invalid.
Another example is that `uint256` is valid however `uint257` is not.

Once each function has been validated they will all be concatenated into one long
javascript string with a salt starting with the value of 0.
The long string will be hashed using web3's keccak256 function and used to check
for collisions.
If there is a collision then the value of 0 will be incremented to 1 and the string
will need to be hashed again and checked for collisions.
Repeat the process until there are no more collisions.

== Requirements

. A function cannot have any spaces and must have valid data types
.. Invalid function that cannot be fixed `withdraw (strings, uint257 )`
.. Valid function that can be fixed `withdraw (string, uint256 )` -> `withdraw(string,uint256)`

. The validated functions must be concatenated in the order that the user has specified
in their workflow
.. E.g. `withdraw(string,uint256)invest(string,uint256)pay(string,unit256)`

. Concatenated string must go through a process of finding a valid salt
.. Append the value of 0 to `withdraw(string,uint256)invest(string,uint256)pay(string,unit256)`
to get `withdraw(string,uint256)invest(string,uint256)pay(string,unit256)0`
.. Hash the string using keccak256
.. If there is a collision then increment that 0 by 1 value to get `withdraw(string,uint256)invest(string,uint256)pay(string,unit256)1`
and hash again
.. Repeat incrementing process until there are no collisions

== Future improvements

. Add custom type checking instead of only relying on the inbuilt types
