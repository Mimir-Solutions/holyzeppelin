== Overview

A workflow ID is used for differentiating between different workflows.
The workflow ID consists of functions being concatenated together and a salt appended
to the end in order to handle collisions in the hashtable.

== Context

Each function will be validated by removing any spaces and ensuring that the arguments
that are provided into the function are valid for example the type `string` is valid
however `strings` does not exist and is thus invalid.
Another example is that `uint256` is valid however `uint257` is not.

Once each function has been validated they will all be concatenated into one long
string with a salt appended to the end starting with the value of `0`.
The long string will be hashed using web3's keccak256 function and used to check
for collisions.
If there is a collision then the value of `0` will be incremented by `1` and the string
will need to be hashed again and checked for collisions.
Repeat the process until there are no more collisions at which point a valid workflow
ID has been generated.

== Requirements

. A function cannot have any spaces and must have valid data types
.. Invalid function that cannot be fixed `withdraw (strings, uint257 )`
.. Valid function that can be fixed `withdraw (string, uint256 )` -> `withdraw(string,uint256)`

. The validated functions must be concatenated in the order that the user has specified
in their workflow
.. E.g. if they have 3 functions in the following order
... 1) `withdraw(string,uint256)`
... 2) `invest(string,uint256)`
... 3) `pay(string,unit256)`
.. Then the string should be `withdraw(string,uint256)invest(string,uint256)pay(string,unit256)`

. The function string should contain a salt at the end that does not cause a hash collision.
.. Start with the value of `0` to get `withdraw(string,uint256)invest(string,uint256)pay(string,unit256)0`
.. A hash collision results in the increment of the salt by 1 therefore the next
string to hash is `withdraw(string,uint256)invest(string,uint256)pay(string,unit256)1`
.. Repeat until a hash collision does not occur


== Future improvements

. Add custom type checking instead of only relying on the inbuilt types
